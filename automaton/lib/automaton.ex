defmodule Automaton do
  @moduledoc """
  Documentation for Automaton.

  An Automaton struct requires three parameters:
    - transitions: A list of length three with the current state, input symbol,
    and next state, respectively.
    - initial_state: The initial state of the automaton.
    - accept_states: A list of the automaton's acceptance states.
  """
  @enforce_keys [:transitions, :initial_state, :accept_states]
  defstruct [:transitions, :initial_state, :accept_states]

  @doc """
  Given a deterministic finite automaton and a list, returns whether that list
  belongs to the regular language generated by the automaton.

  ## Parameters
    - word: the list representing a word to be verified against the language
    - automaton: the Automaton struct for the DFA

  ## Examples

      iex> Automaton.dfa_generates_word?(%Automaton{transitions: [{:q0, :a, :q1}, {:q1, :a, :q2}, {:q2, :a, :q2}], initial_state: :q0, accept_states: [:q2]}, [:a])
      false
      iex> Automaton.dfa_generates_word?(%Automaton{transitions: [{:q0, :a, :q1}, {:q1, :a, :q2}, {:q2, :a, :q2}], initial_state: :q0, accept_states: [:q2]}, [:a, :a])
      true

  """
  def dfa_generates_word?(automaton, word) do
    Enum.member?(
      automaton.accept_states,
      Enum.reduce( # Use reduce to find the last state
        word, # Enumerable: Input word (list of symbols)
        automaton.initial_state, # Accumulator: Initial state
        fn(symbol, current_state) -> elem(Enum.find( # Get transition for current state and current symbol
          automaton.transitions,
          fn(transition) ->
            elem(transition, 0) == current_state and elem(transition, 1) == symbol
          end), 2) end)) # Get third element of appropriate transition (next state)
  end

  def convert_nfa_to_dfa(automaton) do
    elements = Enum.sort(Enum.uniq(Enum.map(automaton.transitions, fn(x) -> elem(x, 1) end)))
    %Automaton{transitions: [], initial_state: [automaton.initial_state], accept_states: []}
  end

  def get_reachable_states(current_states, symbol, transitions) do
    new_states = Enum.sort(Enum.uniq( # Format list to clean order
      Enum.reduce(
        Enum.map(current_states, fn(state) ->
          Enum.map(
            Enum.filter(transitions, fn(trans) -> elem(trans, 0) == state and elem(trans, 1) == symbol end), # Filter applicable transitions
            fn(transition) -> elem(transition, 2) end) # Get state for filtered transitions
        end),
      [], fn(x, acc) -> acc ++ x end # Join all reachable states in a single list
      ) ++ if symbol == nil do current_states else [] end)) # On an empty symbol transition, include current states
    if symbol == nil and new_states == current_states do # End iterations when we can no longer reach any new states
      current_states
    else
      get_reachable_states(new_states, nil, transitions) # Recursively try to find more states to reach
    end
  end
end
