defmodule Automaton do
  @moduledoc """
  Documentation for Automaton.

  An Automaton struct requires three parameters:
    - transitions: A list of length three with the current state, input symbol,
    and next state, respectively.
    - initial_state: The initial state of the automaton.
    - accept_states: A list of the automaton's acceptance states.
  """
  @enforce_keys [:transitions, :initial_state, :accept_states]
  defstruct [:transitions, :initial_state, :accept_states]

  @doc """
  Given a deterministic finite automaton and a list, returns whether that list
  belongs to the regular language generated by the automaton.

  ## Parameters
    - word: the list representing a word to be verified against the language
    - automaton: the Automaton struct for the DFA

  ## Examples

      iex> Automaton.dfa_generates_word?(%Automaton{transitions: [{:q0, :a, :q1}, {:q1, :a, :q2}, {:q2, :a, :q2}], initial_state: :q0, accept_states: [:q2]}, [:a])
      false
      iex> Automaton.dfa_generates_word?(%Automaton{transitions: [{:q0, :a, :q1}, {:q1, :a, :q2}, {:q2, :a, :q2}], initial_state: :q0, accept_states: [:q2]}, [:a, :a])
      true

  """
  def dfa_generates_word?(automaton, word) do
    Enum.member?(
      automaton.accept_states,
      Enum.reduce( # Use reduce to find the last state
        word, # Enumerable: Input word (list of symbols)
        automaton.initial_state, # Accumulator: Initial state
        fn(symbol, current_state) -> elem(Enum.find( # Get transition for current state and current symbol
          automaton.transitions,
          fn(transition) ->
            elem(transition, 0) == current_state and elem(transition, 1) == symbol
          end), 2) end)) # Get third element of appropriate transition (next state)
  end

  @doc """
  Given a non-deterministic finite automaton and a list, returns whether that list
  belongs to the regular language generated by the automaton.

  ## Parameters
    - word: the list representing a word to be verified against the language
    - automaton: the Automaton struct for the NFA

  ## Examples

      iex> Automaton.nfa_generates_word?(%Automaton{initial_state: :q0, accept_states: [:q1], transitions: [{:q0, :a, :q1}, {:q1, :a, :q1}, {:q1, nil, :q2}, {:q2, :b, :q0}]}, [:a, :b])
      false
      iex> Automaton.nfa_generates_word?(%Automaton{initial_state: :q0, accept_states: [:q1], transitions: [{:q0, :a, :q1}, {:q1, :a, :q1}, {:q1, nil, :q2}, {:q2, :b, :q0}]}, [:a, :a])
      true

  """
  def nfa_generates_word?(automaton, word) do
    dfa_generates_word?(convert_nfa_to_dfa(automaton), word)
  end

  @doc """
  Given a non-deterministic finite automaton,
  generate an equivalent deterministic finite automaton.

  ## Parameters
    - automaton: the Automaton struct for the NFA

  ## Examples

      iex> Automaton.convert_nfa_to_dfa(%Automaton{transitions: [{:q0, :a, :q1}, {:q1, :b, :q0}], initial_state: :q0, accept_states: [:q0]})
      %Automaton{
        accept_states: [[:q0]],
        initial_state: [:q0],
        transitions: [
          {[], :a, []},
          {[], :b, []},
          {[:q0], :a, [:q1]},
          {[:q0], :b, []},
          {[:q1], :a, []},
          {[:q1], :b, [:q0]}
        ]
      }

  """
  def convert_nfa_to_dfa(automaton) do
    symbols = Enum.sort(Enum.uniq( # Get all non-nil symbols from transitions
      Enum.filter(
        Enum.map(automaton.transitions, fn(x) -> elem(x, 1) end),
      fn(x) -> x != nil end)))
    initial_state = get_reachable_states([automaton.initial_state], nil, automaton.transitions) # Initial state will be a set of states reachable from start position
    new_transitions = get_dfa_transitions( # Transform NFA transitions into DFA
      [initial_state], # Pass a list for iterating states (currently, a list containing only the initial state)
      symbols,
      automaton.transitions,
      Enum.map(symbols, fn(x) -> {[], x, []} end))
    %Automaton{
      transitions: new_transitions,
      initial_state: initial_state, # Initial state is now a set containing the initial state
      accept_states: Enum.sort(Enum.uniq(Enum.filter( # Accept states are all reachable states containing at least one of the original accept states
        [[automaton.initial_state]] ++ Enum.map(
          new_transitions,
          fn(t) -> elem(t, 0) end),
        fn(states) -> Enum.any?(states, fn(state) -> Enum.member?(automaton.accept_states, state) end) end)))}
  end

  defp get_dfa_transitions(iterated_states, symbols, transitions, current_transitions) do
    new_transitions = Enum.sort(Enum.uniq(Enum.map(
      symbols, fn(symbol) -> { # For each possible input symbol...
        Enum.at(iterated_states, 0), # ... when standing at the currently iterated state set...
        symbol,
        get_reachable_states(Enum.at(iterated_states, 0), symbol, transitions) # ... find all reachable sets...
      } end
    ) ++ current_transitions)) # ... and append to previously saved transitions.
    next_state = Enum.find( # Find the next state set to iterate from the list of reachable state sets (i.e. 3rd element of transition tuples), avoiding previously iterated ones
      new_transitions, fn(trans) -> not Enum.member?(iterated_states, elem(trans, 2)) and elem(trans, 2) != [] end)
    if next_state == nil do # No more states to iterate; finish iterations and return
      new_transitions
    else
      get_dfa_transitions([elem(next_state, 2) | iterated_states], symbols, transitions, new_transitions) # Recurse over new state set
    end
  end

  defp get_reachable_states(current_states, symbol, transitions) do
    new_states = Enum.sort(Enum.uniq( # Format list to clean order
      Enum.reduce(
        Enum.map(current_states, fn(state) ->
          Enum.map(
            Enum.filter(transitions, fn(trans) -> elem(trans, 0) == state and elem(trans, 1) == symbol end), # Filter applicable transitions
            fn(transition) -> elem(transition, 2) end) # Get state for filtered transitions
        end),
      [], fn(x, acc) -> acc ++ x end # Join all reachable states in a single list
      ) ++ if symbol == nil do current_states else [] end)) # On an empty symbol transition, include current states
    if symbol == nil and new_states == current_states do # End iterations when we can no longer reach any new states
      current_states
    else
      get_reachable_states(new_states, nil, transitions) # Recursively try to find more states to reach
    end
  end
end
