defmodule Grammar do
  @moduledoc """
  Documentation for Grammar.
  """

  @doc """
  Given a context-sensitive grammar and a list, returns whether that list
  belongs to the language generated by the grammar.

  ## Parameters
    - list: the list representing a word to be verified against the language
    - start: the start non-terminal for the grammar
    - rules: the list of tuples representing grammar rules
    - terms: the list of terminals of the grammar
    - nonterms: the list of non-terminals of the grammar

  ## Examples

      iex> Grammar.generates_word?([:a, :a, :b], :S, [{[:S], [:a, :S, :b]}, {[:S], [:a, :b]}], [:a, :b], [:S])
      false
      iex> Grammar.generates_word?([:a, :a, :b, :b], :S, [{[:S], [:a, :S, :b]}, {[:S], [:a, :b]}], [:a, :b], [:S])
      true

  """
  def generates_word?(list, start, rules, terms, nonterms) do
    contains?(list, generate_all(size(list), start, rules, terms, nonterms))
  end

  @doc """
  Given a context-sensitive grammar and a length, generates all possible words
  of the language with size less than or equal to the provided length.
  The generated list will be ordered and will have unique elements.

  ## Parameters
    - length: the max length as an integer of generated strings
    - start: the start non-terminal for the grammar
    - rules: the list of tuples representing grammar rules
    - terms: the list of terminals of the grammar
    - nonterms: the list of non-terminals of the grammar

  ## Examples

      iex> Grammar.generate_all(4, :S, [{[:S], [:a, :S]}, {[:S], [:a]}], [:a], [:S])
      [[:a], [:a, :a], [:a, :a, :a], [:a, :a, :a, :a]]

  """
  def generate_all(length, start, rules, terms, nonterms) do
    generate(length, [], [], [start], rules, rules, terms, nonterms) |> unique() |> sort()
  end

  @doc """
  Receives a list and returns the list with unique elements.

  ## Parameters
    - list: the input list

  ## Examples
      iex> Grammar.unique([2, 1, 3, 1, 4, 3, 2, 5])
      [2, 1, 3, 4, 5]

  """
  def unique(list) do
    case list do
      [] -> []
      [head | tail] -> [head] ++ unique(remove_duplicates_of(head, tail))
    end
  end

  @doc """
  Receives a list and returns the ascending sorted list through bubblesort.

  ## Parameters
    - list: the input list

  ## Examples
      iex> Grammar.sort([2, 1, 3, 1, 4, 3, 2, 5])
      [1, 1, 2, 2, 3, 3, 4, 5]

  """
  def sort(list) do
    case list do
      [] -> []
      [head | tail] ->
        {smallest, new_tail} = get_smallest_element(head, tail)
        [smallest] ++ sort(new_tail)
    end
  end

  defp generate(length, prev, curr, next, rules, orig_rules, terms, nonterms) do
    # Parar recursão quando a palavra for maior que o tamanho máximo
    if size(next) > length do
      []
    else
      case curr do
        [] -> # curr vazio
          case next do
            [] ->
              # Verificar se prev é uma palavra com apenas terminais
              if is_made_of?(prev, terms) do
                [prev]
              else
                []
              end
            [head | tail] ->
              # Mover primeiro valor de next para curr
              generate(length, prev, [head], tail, rules, orig_rules, terms, nonterms)
          end
        [_ | _] -> # curr com um ou mais elementos
          case rules do
            [] ->
              # Aplicar iteração da cadeia
              case next do
                [] ->
                  generate(length, prev ++ curr, [], [], orig_rules, orig_rules, terms, nonterms)
                [head | tail] ->
                  generate(length, prev, curr ++ [head], tail, orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev ++ curr, [head], tail, orig_rules, orig_rules, terms, nonterms)
              end
            [{^curr, subst} | rules_tail] ->
              # Aplicar recursão + iteração das regras
              case next do
                [] ->
                  generate(length, [], [], prev ++ subst ++ next, orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev ++ curr, [], [], orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev, curr, next, rules_tail, orig_rules, terms, nonterms)
                [head | tail] ->
                  generate(length, [], [], prev ++ subst ++ next, orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev, curr ++ [head], tail, orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev ++ curr, [head], tail, orig_rules, orig_rules, terms, nonterms) ++
                  generate(length, prev, curr, next, rules_tail, orig_rules, terms, nonterms)
              end
            [_ | rules_tail] ->
              # Aplicar iteração das regras
              generate(length, prev, curr, next, rules_tail, orig_rules, terms, nonterms)
          end
      end
    end
  end

  defp size(list) do
    case list do
      [] -> 0
      [_ | tail] -> 1 + size(tail)
    end
  end

  defp is_made_of?(word, terms) do
    case word do
      [] -> true
      [head | tail] ->
        if contains?(head, terms) do
          is_made_of?(tail, terms)
        else
          false
        end
    end
  end

  defp contains?(elem, list) do
    case list do
      [] -> false
      [^elem | _] -> true
      [_ | tail] -> contains?(elem, tail)
    end
  end

  defp remove_duplicates_of(elem, list) do
    case list do
      [] -> []
      [^elem | tail] -> remove_duplicates_of(elem, tail)
      [head | tail] -> [head] ++ remove_duplicates_of(elem, tail)
    end
  end

  defp get_smallest_element(elem, list) do
    case list do
      [] -> {elem, list}
      [head | tail] ->
        if head < elem do
          {smallest, new_tail} = get_smallest_element(head, tail)
          {smallest, [elem] ++ new_tail}
        else
          {smallest, new_tail} = get_smallest_element(elem, tail)
          {smallest, [head] ++ new_tail}
        end
    end
  end
end
